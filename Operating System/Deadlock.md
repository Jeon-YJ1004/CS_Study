# Deadlock(교착상태)
일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태   

각자 일부자원을 가지고있으면서, 상대방이 가진 자원을 요구하고, 상대방도 내놓지않고 다른자원을 요구하는 상태

## Resource
- 하드웨어, 소프트웨어 등을 포함하는 개념   
  (예) I/O device, CPU cycle, memory space, semaphore 등
- 프로세스가 자원을 사용하는 절차 (Request -> Allocate -> Use -> Release)
### Deadlock 예시

- 시스템에 2개의 tape drive가 있다.   
프로세스 p1과 p2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리는 상태
- Binary semaphore A와 B


## Deadlock 발생 필요충분 조건 4가지 
- **1 Mutual exclusion(상호배제)**:   
매 순간 하나의 프로세스만이 자원을 사용할 수 있음
- **2 No preemption(비선점)**:   
프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- **3 Hold and wait(보유대기)**:   
자원을 가진 프로세스가 다른 자원을 기다릴 때 보유자원을 놓지않고 계속 가지고 있음
- **4 Circular wait(순환대기)**:   
자원을 기다리는 프로세스간에 사이클이 형성되어야함

_상호 배제는 수행 결과의 일관성과 데이터베이스의 무결성을 보장하기 위해 반드시 필요함.   
또한 선점도 임의대로 수행되어서는 안되고, 프로세스가 다시 재수행될 수 있도록 프로세스의 상태와 사용하던 자원의 상태를 안정적인 이전의 상태로 복원할 수 있어야 선점이 가능하다._

_조건 4 순환대기는 조건 1~3의 결과에 의해 발생한다.
교착상태의 정의가 바로 해결할 수 없는 환형 대기 상태이다. 환형 대기 상태가 해결될 수 없는 이유는 조건 1~3이 지켜지기 때문이다.    
즉 위 네 가지 조건이 교착상태가 발생할 수 있는 필요충분조건이다._

## Deadlock의 처리 방법
- **Deadlock Prevention**:   
자원 할당시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는것
- **Deadlock Avoidance**:   
자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당
시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당
- **Deadlock Detection and recovery**:   
Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock발견시 recover
- **Deadlock Ignorance**(현대의 운영체제는 대부분 이 방식을 채택함):   
Deadlock을 시스템이 책임지지 않음(UNIX 등 대부분 OS)

## Deadlock Prevention 

교착상태 예방 전략은 운영체제를 설계할 때 교착상태가 발생할 가능성을 애초에 없애는 것.   
교착상태가 발생하기 위한 네 가지 필요충분조건 중에 하나를 설계 단계에서 배제하는 것임.   

- Mutual exclusion(상호배제)   
공유해서는 안되는 자원의 경우 반드시 성립해야함
(이 조건은 항상 만족시켜야 하기때문에 다른 조건을 만족시키지 않는 방법을 찾아야함.)
- Hold and wait(보유대기)
  - 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고있지 않아야한다.
  - 방법1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법(but 자원을 비효율적으로 관리)
  - 방법2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
- No preemption(비선점)
  - 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선정됨
  - 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.
  - state를 쉽게 save하고 (빼앗긴 시점 다음부터 실행할 수 있도록)restore 할 수 있는 자원에서 주로 사용(CPU, memory)
- Circular wait(순환대기)
  - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
  - ex) 순서가 3인 자원 R을 보유 중인 프로세스가 순서가 1인 자원 R을 할당받기 위해서는 우선 (순서가 3인)R을 release 해야한다.
  
**=>Utilization 저하, throughtput 감소, starvation 발생**

## Deadlock Avoidance
교착상태 회피는 교착상태 발생 조건 중 1~3은 허용한다. 그 대신 자원을 할당할 때 교착상태가 발생 가능한 상황으로 진행하지 않도록 고려한다.    
따라서 회피 방법은 예방 방법에 비해 더 많은 병행성을 제공한다(자원 사용의 효율성이 높다).   
회피 방법은 현재 자원의 가용 개수와 프로세스의 자원 요구량을 미리 알고 있어야 가능하다.
- 2가지 경우의 avoidace 알고리즘
  - Single instance per resouce types(리소스 당 하나의 인스턴스 일때): Resource Allocation Graph algorithm
  - Multiple instance per resouce types:Banker's algorithm
- 자원 요청에 대한 부가정보를 이용해서 자원 할당이 deadlock으로부터 안전한지를 동적으로 조사해서 안전한 경우에만 할당
- 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법
- safe state:   
  시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태.
  No Deadlock, 시스템이 unsafe state에 있으면 possibility of deadlock
- safe sequence:   
  - 프로세스의 sequence<P1, P2, ..., Pn>가 safe하려면 Pi(1<= i <= n)의 자원 요청이 가용자원 + 모든 Pj(j < i)가 의 보유자원에 의해 충족되어야 함
  - 조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장
    - Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj(j < i)가 종료될 때까지 기다린다.
### Banker's Algorithm
- 운영체제는 자원의 상태를 감시하고, 사용자 프로세스는 사전에 자신의 작업에서 필요한 자원의 수를 제시하는 교착상태 회피 알고리즘
- 운영체제는 안정상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 교착상태 회피 알고리즘

#### 장점:
- 교착상태 회피는 교착상태 예방에 비해 자원 할당이 더 자유롭다.
  따라서 시스템에서 자원 효율이 높아진다. 
- 교착상태 발견에 비해 자원을 선점하고 프로세스 수행의 롤백(rollback)이 필요 없다는 장점이 있다.

#### 단점:
- 각 프로세스들이 사용할 최대 자원 요구량을 미리 운영체제에 알려주어야 한다.
- 프로세스들은 서로 독립적이어야 한다.
  즉 프로세스들 중에 한 프로세스는 다른 프로세스에 비해 먼저 수행되어야 한다는 것과 같은 수행 순서 종속 관계가 없어야 한다.
- 자원 개수가 고정되어 있어야 한다.
- 자원을 선점한 채 종료되는 프로세스는 없어야 한다.

## Deadlock Detection and Recovery
순환대기와 회피로 데드락을 원천적으로 차단할 경우 효율성 문제가 발생. 많은 규제와 많은 대기, 이로 인한 기아상태 등의 문제가 발생.   
데드락은 분명 발생할 수 있으나 자주 발생하는 것은 또한 아님. 그러므로 데드락의 발생을 허용 하되, 문제 발생에 대한 처리를 사후적으로 함.

### Deadlock Detection
자원 접근에 대한 제한이나 프로세스의 행위에 제한을 두지 않는다. 즉 자원 할당이 가능한 상황이면 항상 할당을 해 준다. 단 주기적으로 시스템에 환형 대기조건이 발생하였는지 검사하고, 만일 발생하였으면 그것을 해결해 준다.
시스템의 상태가 점진적으로 변하기 때문에 발견 알고리즘도 간단해 진다는 장점이 있다.
반면, 매번 시도될 때마다 발생하는 처리 비용이 커진다는 단점이 있다.

5.2 교착상태 회복 알고리즘
그러나 만약 P2의 request가 111로 변할 경우, p0이 배출하는 자원이 010 밖에 없으므로 데드락이 발생한다.
- Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견 시 recover
- Resource type 당 single instance일 경우: 자원 할당 그래프에서의 cycle이 곧 deadlock을 의미
- Resource type 당 multiple instance인 경우: Banker's algorithm과 유사한 방법 활용
- Wait-for graph 알고리즘
  - Resource type 당 single instance인 경우
  - Wait-for graph: 자원 할당 그래프의 변헝, 프로세스만으로 node 구성, Pj가 가지고 있는 자원을 Pk가 기다리는 경우 Pk -> Pj
- Algorithm: Wait-for graph에 cycle이 존재하는지를 주기적으로 조사(효율성: O(n2))
Wait-for graph를 통하여 데드락이 발생했는지를 찾는다. 해당 그래프는 (n)(n-1)으로서 O(n^2)만큼의 시간 복잡도를 가진다.
### Recovery

- 1. Process termination
  - 모든 교착상태 프로세스 kill, 하나씩 종료하여 작동하는지 확인
- 2. Resource Preemption
  - 비용을 최소화할 resource(victim)의 선정
  - safe state로 rollback하여 process를 restart
  - starvation 문제 발생 우려 
    => 동일한 프로세스가 계속해서 victim으로 선정되는 경우 cost factor에 rollback 횟수도 같이 고려하면 문제 발생 확률 낮아짐
<details>  
<summary>Recovery process</summary>

- 착상태에 포함되어 있는 모든 프로세스들을 중지시킴. (실제로 많은 운영체제에서 사용하고 있는 방법 중에 하나)   

  교착상태에 포함되어 있는 각 프로세스의 수행을 롤백시킴. 즉, 미리 정의된 특정 체크포인트 시점까지 되돌린 후 다시 수행시킨다.   
 이 방법의 단점은 다시 수행시켰을 때 다시 교착상태에 빠질 수 있다는 것이다. 하지만 병행 처리의 비결정 특성은 이 가능성을 적게 한다.

- 교착상태가 없어질 때까지 교착상태에 포함되어 있는 프로세스들 하나씩 종료시킴. 
  종료시킬 프로세스의 선택은 비용이 가장 적은 것으로 한다. 하나씩 종료시킨 후 교착상태 발견 알고리즘을 다시 수행시켜보면 아직 교착상태가 존재하는지 여부를 알 수 있다.
- 교착상태가 없어질 때까지 교착상태에 포함되어 있는 자원을 하나씩 선점시킴.
  자원 선택은 비용이 가장 적은 자원부터 선택한다. 그리고 하나씩 선점한 후 교착상태 발견 알고리즘을 수행시켜 아직 교착상태가 존재하는지 파악한다.   
  이때 자원을 선점 당한 프로세스는 자원을 할당 받기 전 시점으로 롤백하고, 그 시점부터 다시 수행한다.
프로세스의 선택은 다음과 같은 기준을 적용할 수 있다.
  - 지금까지 사용한 처리기 시간이 적은 프로세스부터
  - 지금까지 생산한 출력량이 적은 프로세스부터
  - 이후 남은 수행시간이 가장 긴 프로세스부터
  - 할당받은 자원이 가장 적은 프로세스부터
  - 우선순위가 낮은 프로세스부터
</details>

## Deadlock Ignorance
6번의 방법 역시도 데드락을 예측하기 위한 비용이 소모 되고, 해결을 위한 비용이 다시 소모된다.   
데드락 해소를 위한 오버헤드보다 데드락에 대한 해결 자체를 포기하며 발생하는 이점이 크다는 것을 전제한다.   
데드락이 발생하면 프로그램이 작동을 멈추거나 오류를 발생할 텐데, 이를 커널이 해소하지 않고, 사용자가 직접 프로세스를 종료함.

- Deadlock을 시스템이 책임지지 않음. Deadlock이 일어나지 않는다고 가정하고 아무런 조치도 취하지 않음.
  - Deadlock이 매우 드물게 발생하므로 Deadlock에 대한 조치 자체가 더 큰 overhead일 수 있음.
  - 만약, 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처.
  - UNIX, windows를 포함한 대부분의 OS가 채택

