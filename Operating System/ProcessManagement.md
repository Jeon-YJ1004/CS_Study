## Process 생성

- 부모 프로세스가 자식 프로세스를 생성(memory, PC register 복제)
- 프로세스의 트리 형성
- 자식은 부모의 공간을 복사함(binary and OS data), 그 공간에 새로운 프로그램을 올림

### 모델 종류

- 프로세스 자원
  - 운영체제로부터 받는다
  - 부모와 공유한다
- 자원 공유
  - 부모와 자식이 모든 자원 공유
  - 일부 공유
  - 전혀 공유하지 않는 모델
  - 리눅스 등은 메모리 낭비를 없애기 위해 최대한 공유하고 달라질 때 복제(Copy-on-write)
- 수행(Execution)

  - 부모와 자식은 공존하며 수행되는 모델
  - 자식이 종료될 때까지 부모가 기다리는 모델

- exit(): 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌
  - 자식이 부모에게 output data 보냄(wait)
  - 프로세스의 각종 자원들이 운영체제에게 반납됨
- abort(): 부모 프로세스가 자식의 수행을 종료시킴
  - 자식이 할당 자원의 한계치를 넘어섬
  - 자식에게 할당된 태스크가 더 더이상 필요하지 않음
  - 부모가 exit하는 경우

### fork 시스템 콜

fork: 시스템 콜이(운영체제가) 새로운 프로세스를 생성=> 부모를 그대로 복사(OS data except PID+binary) 후 주소 공간 할당.

자식 프로세스는 부모 프로세스의 fork가 일어난 다음부터 실행됨.  
자식과 부모는 pid=fork()를 통해 return value로 구분.

### exec 시스템 콜

자식프로세스는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림.  
exec() 시스템 콜로 덮여 씌여버리기 때문에 이후의 코드는 실행이 안됨.

### wait 시스템 콜

프로세스 a가 wait 시스템 콜을 호출하면 커널은 child가 종료될 때까지 프로세스 a를 sleep시킨다(block 상태)

자식 프로세스가 종료되면 커널은 프로세스 a를 깨운다(ready 상태)

### exit 시스템 콜

프로세스의 종료

- 자발적 종료: 마지막 statement 수행 후 exit() 시스템콜을 통해. 프로그램에 명시적으로 넣어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적 종료
  - 부모가 프로세스가 자식 프로세스를 강제 종료 시킴.
  - 키보드로 kill, break 등을 친 경우
  - 부모가 종료하는 경우

## 프로세스 간 협력

- 독립적 프로세스(independent process): 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
- 협력 프로세스(Cooperating process): 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스에 수행에 영향을 미칠 수 있음
- 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
  - message passing: 커널을 통해 메세지 전달
  - shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 메커니즘
  - thread: 사실상 하나의 프로세스로 프로세스 간 협력으로 보긴 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능

### message passing

프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템. 커널을 통해 메세지 전달

- Direct Communication: 통신하려는 프로세스의 이름을 명시적으로 표시
- Indirect Communication: mailbox(또는 port)를 통해 메세지를 간접 전달

### shared memory

커널한테 공유한다고 mapping 할때 알려주고 그 이후는 사용자 process에서 관할.
