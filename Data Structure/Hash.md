## 해시 (Hash) / 해시 테이블(Hash Table)

<br/>
해시는 해시 함수를 통해 key를 고정된 길이의 해시로 변경하여 해시 테이블에 key와 values를 1대 1 매핑하는 기술이나 과정이다.

<br/>

<img src="https://www.geeksforgeeks.org/wp-content/uploads/HashingDataStructure-min-1024x512.png" width="60%"><br/>

key를 이용하여 원소 접근이 빠르고, key 자체를 저장하는 것보다 고정된 길이를 저장하기 때문에 메모리를 효율적으로 쓸 수 있다. 또한 효율적인 매핑은 어떤 해시 함수를 쓰느냐에 따라 결정된다.  
하지만 해시 값을 저장한 공간(bucket)을 따로 지정해야하므로 일반적으로 저장 공간이 많이 필요하다.  
순서가 있는 배열에는 어울리지 않으며(순서와 상관없이 key만 가지고 저장하므로), 데이터가 저장되기 전에 미리 hash table 공간을 확보해야하므로 공간 효율성이 떨어진다.

파이썬에서 dictionary type이 해시 구조이다.

<br/>

---

<br/>

## 해시 연산<br/>

해시 테이블에서 연산은 삽입(저장), 삭제, 검색이 있다. 각각의 시간 복잡도는 충돌이 일어나지 않는다는 가정하에 O(1)이다. 해시 함수의 시간 복잡도는 함께 고려하지 않는다.  
따라서 연산이 많은 경우 사용된다.

위에 언급한 충돌은 데이터가 많아지면, 다른 key임에도 같은 해시 값으로 충돌나는 현상이다. 비둘기집 원리로 인해 해시에서는 무조건적으로 일어날 수 밖에 없다.

해시 충돌로 인해 모든 bucket을 찾아봐야 하는 경우 연산의 시간 복잡도는 O(n)이 된다.

---

<br/>

## 해시 충돌(Hash Collision)

<br/>

무한한 value을 유한한 Hash로 표현하기 때문에 서로 다른 두개 이상의 유한한 값이 동일한 출력 값을 가질 수 밖에 없다.  
충돌을 해결하기 위해서는 아래와 같이 2 방법이 있다.
<br/>

### Chaining(Separate Chaining)

만약 bucket에 충돌이 일어나면 기존 bucket에 삽입하고 싶은 값을 차례로 연결한다. 연결 리스트 구조 이용.

<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/07/hashChaining1.png"> <br/>

장점 : 간단. 한정된 해시 테이블에 효율적. 상대적으로 적은 메모리를 사용한다.(미리 공간을 잡을 필요 ㄴㄴ)해시 함수에 대해 덜 민감. 키 개수나 연산 빈도를 모를때 자주 사용된다. <br/>

단점 : 캐시 성능이 좋지 않다.(한 테이블에 저장되지 않으므로=추가 공간이 cache locality ㄴㄴ) 테이블의 공간 소모가 한 곳으로 몰릴 수 있다(한 해시에만 연결). 체인이 길면 검색 연산의 시간 복잡도가 최악 O(n). 메모리의 추가 사용

### Open Addressing(Close hashing, Linear probing )

<br/>

해시가 변경되지 않는 chaining과 달리 비어있는 해시를 찾아 해시 함수로 얻는 주소가 아닌 빈(자리가 없다면 테이블 주소를 추가하여) 주소에 데이터 저장하는 기법. 1 대 1 매핑 형태 유지한다.  
비어있는 해시를 찾는 과정을 일정한 규칙을 따라 찾는다. <br/>

<br/>

- 선형탐색 : 다음 해시나 n개를 건너 뛴 해시에 데이터 저장. 캐쉬 성능이 제일 좋지만 클러스터 문제가 있다.<br/>

- 제곱탐색 : 해시값의 제곱을 한 해시에 데이터 저장.

- 이중해시 : 다른 해시 함수를 한번더 적용한 해시에 데이터 저장. 클러스터링 문제가 없다. 하지만 연산이 두번 필요하다.   
<br/>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/08/openAddressing1.png">   

장점 : 추가 저장 공간 없이 해시 테이블 내에서 데이터 저장 및 처리가 가능하다. <br/>

단점 : 해시 함수에 의해 성능 차이가 크다. 데이터 길이가 늘어나면 그에 따라 테이블도 추가된다. 비어있는 공간을 확보하지 않으면 연산의 시간 복잡도가 O(n)이 될 수 있다.
